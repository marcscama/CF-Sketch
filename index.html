<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>CF-Sketch</title>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.179.1/build/three.module.js"
  }
}
</script>

<style>
  html,body{height:100%;margin:0;overflow:hidden;font-family:Arial,Helvetica,sans-serif}
  #canvas-container{width:100%;height:100%;position:relative;background:#e9eef3}
  .ui{position:absolute;left:12px;top:12px;background:rgba(255,255,255,0.95);padding:8px;border-radius:8px;box-shadow:0 6px 18px rgba(0,0,0,0.12);z-index:10;min-width:156px}
  .ui label{display:block;font-size:13px;margin-top:6px}
  .ui input[type="range"]{width:100%}
  .btn{display:inline-block;margin-top:8px;padding:6px 10px;border-radius:6px;cursor:pointer;border:1px solid #bbb;background:#fafafa}
  .btn.active{background-color:#ffcccc}
  .mode-toggle{display:flex;gap:8px;margin-top:6px;align-items:center}
  #dropHint{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);padding:16px 22px;border-radius:10px;background:rgba(255,255,255,0.9);box-shadow:0 6px 24px rgba(0,0,0,0.12);z-index:9;font-size:14px;pointer-events:none}
  #dropHint.hidden{display:none}
  #selected-terrain-name{font-size:12px;color:#333;margin-top:6px;}
</style>
</head>
<body>
<div id="canvas-container"></div>
<div id="dropHint">Trascina qui un file <strong>.glb</strong> o <strong>.gltf</strong> per caricare il modello</div>

<div class="ui" id="ui">
  <div style="display:flex;justify-content:space-between;align-items:center">
    <div><strong>Pannello sketch</strong></div>
    <div style="display:flex;align-items:center;gap:8px">
      <input id="draw-mode" type="checkbox" style="transform:scale(1.05);margin-right:6px">
      <label for="draw-mode" style="margin:0">Modalità disegno</label>
    </div>
  </div>

  <div class="mode-toggle">
    <label><input type="radio" name="tool" value="pen" checked> Penna</label>
    <label><input type="radio" name="tool" value="eraser"> Cancella</label>
  </div>

  <div style="margin-top:8px">
    <button class="btn" id="move-axis">Muovi assi</button>
  </div>

  <label>Colore penna: <input id="color" type="color" value="#ff3300"></label>
  <label>Spessore penna: <input id="thickness" type="range" min="1" max="200" value="6" step="1"><span id="thickness-val">6</span></label>

  <div id="eraser-controls" style="display:none;">
    <label>Dimensione cancella: <input id="eraser-size" type="range" min="1" max="400" value="80" step="1"><span id="eraser-val">80</span></label>
    <div style="font-size:12px;color:#555;margin-top:4px">Passa con il puntatore per evidenziare. Clic per cancellare (linee o terrain paint).</div>
  </div>

  <div style="margin-top:8px">
    <button class="btn" id="clear-all">Cancella tutto</button>
  </div>

  <button id="load-campi" class="btn" style="margin-top:8px">Carica modello Campi Flegrei</button>

  <div style="margin-top:8px;display:flex;flex-direction:column;gap:6px">
    <button id="terrain-pen" class="btn">Terrain Pen</button>
    <div id="selected-terrain-name">Terrain: <em>nessuno (auto)</em></div>
  </div>
</div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.179.1/examples/jsm/controls/OrbitControls.js';
import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.179.1/examples/jsm/loaders/GLTFLoader.js';
import { Line2 } from 'https://cdn.jsdelivr.net/npm/three@0.179.1/examples/jsm/lines/Line2.js';
import { LineGeometry } from 'https://cdn.jsdelivr.net/npm/three@0.179.1/examples/jsm/lines/LineGeometry.js';
import { LineMaterial } from 'https://cdn.jsdelivr.net/npm/three@0.179.1/examples/jsm/lines/LineMaterial.js';

// dynamic import three-mesh-bvh (build module for correct CORS/MIME)
async function importBVH() {
  const candidates = [
    'https://unpkg.com/three-mesh-bvh@0.9.1/build/index.module.js',
    'https://cdn.jsdelivr.net/npm/three-mesh-bvh@0.9.1/build/index.module.js'
  ];
  for (const url of candidates) {
    try { const m = await import(url); return m; } catch(e){ console.warn('BVH import failed',url,e); }
  }
  throw new Error('Unable to import three-mesh-bvh from CDNs');
}

(async ()=> {
  const bvhModule = await importBVH();
  const MeshBVH = bvhModule.MeshBVH || bvhModule.default?.MeshBVH;
  const acceleratedRaycast = bvhModule.acceleratedRaycast || bvhModule.default?.acceleratedRaycast;
  if (!MeshBVH || !acceleratedRaycast) throw new Error('BVH module missing exports');
  THREE.Mesh.prototype.raycast = acceleratedRaycast;

  // ---------- renderer / scene ----------
  const container = document.getElementById('canvas-container');
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(container.clientWidth, container.clientHeight);
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  container.appendChild(renderer.domElement);

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0xe9eef3);

  const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 100000);
  camera.position.set(0,0,2000);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.mouseButtons = { LEFT: THREE.MOUSE.ROTATE, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: THREE.MOUSE.PAN };

  // lights
  scene.add(new THREE.AmbientLight(0xffffff, 0.6));
  const dir = new THREE.DirectionalLight(0xffffff, 0.8); dir.position.set(1,2,1).multiplyScalar(1000); scene.add(dir);

  // ---------- UI refs ----------
  const drawModeCheckbox = document.getElementById('draw-mode');
  const modeRadios = document.querySelectorAll('input[name="tool"]');
  const colorInput = document.getElementById('color');
  const thicknessInput = document.getElementById('thickness');
  const thicknessVal = document.getElementById('thickness-val');
  const eraserControls = document.getElementById('eraser-controls');
  const eraserSizeInput = document.getElementById('eraser-size');
  const eraserVal = document.getElementById('eraser-val');
  const clearBtn = document.getElementById('clear-all');
  const moveAxisBtn = document.getElementById('move-axis');
  const terrainPenBtn = document.getElementById('terrain-pen');
  const selectedTerrainNameEl = document.getElementById('selected-terrain-name');
  const loadCampiBtn = document.getElementById('load-campi');

  // ---------- loaders / state ----------
  const gltfLoader = new GLTFLoader();
  const CAMPI_URL = 'https://marcscama.github.io/3D/VIPS-Campi-Flegrei.gltf';
  let model = null;
  let currentModelSourceUrl = null;
  let isLoadingCampi = false;
  let terrainMesh = null;

  // ---------- axis helper (1000 units) ----------
  let axisHelper = null;
  function createAxisHelper(center = new THREE.Vector3(0,0,0)) {
    if (axisHelper) {
      scene.remove(axisHelper);
      axisHelper.traverse(o => { if (o.geometry) o.geometry.dispose && o.geometry.dispose(); if (o.material) o.material.dispose && o.material.dispose(); });
      axisHelper = null;
    }
    const axisLength = 1000;
    const g = new THREE.Group();
    g.name = 'axisHelper';
    const headLen = axisLength*0.12, headWidth = axisLength*0.06;
    g.add(new THREE.ArrowHelper(new THREE.Vector3(1,0,0), new THREE.Vector3(0,0,0), axisLength, 0xff0000, headLen, headWidth));
    g.add(new THREE.ArrowHelper(new THREE.Vector3(0,1,0), new THREE.Vector3(0,0,0), axisLength, 0x00ff00, headLen, headWidth));
    g.add(new THREE.ArrowHelper(new THREE.Vector3(0,0,1), new THREE.Vector3(0,0,0), axisLength, 0x0000ff, headLen, headWidth));
    const sphereGeo = new THREE.SphereGeometry(1,32,24);
    const sphereMat = new THREE.MeshBasicMaterial({ color:0xFFF9B0, transparent:true, opacity:0.95 });
    const sphere = new THREE.Mesh(sphereGeo, sphereMat);
    sphere.name = 'axisHelperCenter';
    g.add(sphere);
    const halo = new THREE.Mesh(new THREE.SphereGeometry(1,32,24), new THREE.MeshBasicMaterial({ color:0xFFFF88, transparent:true, opacity:0.35, depthTest:false }));
    halo.name = 'axisHelperHalo'; halo.visible = false; halo.renderOrder = 999;
    g.add(halo);
    g.position.copy(center);
    axisHelper = g;
    scene.add(axisHelper);
    updateAxisCenterVisualSize();
  }

  // ---------- helpers ----------
  const raycaster = new THREE.Raycaster();
  const pointer = new THREE.Vector2();
  const POINTER_APPROX_PX = 16;
  const DESIRED_CENTER_PX = POINTER_APPROX_PX * 2;
  function worldToScreen(point) {
    const p = point.clone().project(camera);
    const x = (p.x * 0.5 + 0.5) * renderer.domElement.width;
    const y = (-p.y * 0.5 + 0.5) * renderer.domElement.height;
    return new THREE.Vector2(x,y);
  }
  function pixelPerMeterAt(point) {
    const p1 = worldToScreen(point);
    const worldX = new THREE.Vector3(1,0,0);
    const test = point.clone().add(worldX);
    const p2 = worldToScreen(test);
    const d = p1.distanceTo(p2);
    if (d < 0.0001) {
      const testY = point.clone().add(new THREE.Vector3(0,1,0));
      const p3 = worldToScreen(testY);
      return Math.max(0.5, p1.distanceTo(p3));
    }
    return Math.max(0.5, d);
  }
  function updateAxisCenterVisualSize() {
    if (!axisHelper) return;
    const sphere = axisHelper.children.find(c => c.name === 'axisHelperCenter');
    const halo = axisHelper.children.find(c => c.name === 'axisHelperHalo');
    if (!sphere || !halo) return;
    const worldPoint = axisHelper.position.clone();
    const pxPerM = pixelPerMeterAt(worldPoint);
    const desiredMeters = Math.max(0.01, DESIRED_CENTER_PX / Math.max(0.0001, pxPerM));
    const clampedMeters = THREE.MathUtils.clamp(desiredMeters, 0.001, 1000);
    sphere.scale.set(clampedMeters * 1.8, clampedMeters * 1.8, clampedMeters * 1.8); // bigger center sphere
    halo.scale.set(clampedMeters * 2.6, clampedMeters * 2.6, clampedMeters * 2.6);
    halo.renderOrder = sphere.renderOrder + 1;
  }

  // ---------- Line2 drawing (classic pen) ----------
  const strokes = []; // each stroke: { segments: [Line2,...], color, thickness_m }
  const minSegmentDistance = 1.2; // meters
  let drawingLine = false;
  let currentStroke = null;
  let lastPoint = null;

  function worldToScreenLocal(point) {
    const p = point.clone().project(camera);
    return new THREE.Vector2((p.x * 0.5 + 0.5) * renderer.domElement.width, (-p.y * 0.5 + 0.5) * renderer.domElement.height);
  }
  function pixelPerMeterAtPoint(point) {
    const p1 = worldToScreenLocal(point);
    const test = point.clone().add(new THREE.Vector3(1,0,0));
    const p2 = worldToScreenLocal(test);
    const d = p1.distanceTo(p2);
    if (d < 0.0001) {
      const testY = point.clone().add(new THREE.Vector3(0,1,0));
      const p3 = worldToScreenLocal(testY);
      return Math.max(0.5, p1.distanceTo(p3));
    }
    return Math.max(0.5, d);
  }

  function createLineSegmentBetweenPoints(p1,p2, thickness_m, colorHex) {
    const positions = [ p1.x, p1.y, p1.z, p2.x, p2.y, p2.z ];
    const geom = new LineGeometry();
    geom.setPositions(positions);
    const mid = new THREE.Vector3().addVectors(p1,p2).multiplyScalar(0.5);
    const pxPerM = pixelPerMeterAtPoint(mid);
    const linewidthPx = Math.max(1, thickness_m * pxPerM);
    const mat = new LineMaterial({
      color: (typeof colorHex === 'string' ? new THREE.Color(colorHex).getHex() : colorHex),
      linewidth: linewidthPx,
      dashed: false,
      resolution: new THREE.Vector2(renderer.domElement.width, renderer.domElement.height)
    });
    mat.resolution.set(renderer.domElement.width, renderer.domElement.height);
    const line = new Line2(geom, mat);
    line.computeLineDistances();
    line.scale.set(1,1,1);
    line.userData._a = p1.clone();
    line.userData._b = p2.clone();
    line.userData._thickness_m = thickness_m;
    line.userData._colorHex = (typeof colorHex === 'string' ? new THREE.Color(colorHex).getHex() : colorHex);
    return line;
  }

  // ---------- BVH & terrain paint ----------
  function ensurePaintColorAttribute(geometry) {
    if (!geometry.attributes.position) return null;
    if (!geometry.attributes.color) {
      const count = geometry.attributes.position.count;
      const arr = new Float32Array(count * 3);
      arr.fill(0);
      geometry.setAttribute('color', new THREE.BufferAttribute(arr, 3));
    }
    return geometry.attributes.color;
  }

  // overlay shader: reads vertex colors; alpha derived from intensity, with a modest global opacity
  const OVERLAY_GLOBAL_OPACITY = 0.65;
  function createOverlayForMesh(mesh) {
    if (!mesh || !mesh.geometry) return null;
    if (Array.isArray(mesh.material)) mesh.material.forEach(m=>m.vertexColors=false);
    else if (mesh.material) mesh.material.vertexColors = false;
    ensurePaintColorAttribute(mesh.geometry);

    const overlayMat = new THREE.ShaderMaterial({
      vertexColors: true,
      transparent: true,
      depthTest: true,
      depthWrite: false,
      blending: THREE.NormalBlending,
      vertexShader: `
        varying vec3 vPaint;
        void main() {
          vPaint = color;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
        }`,
      fragmentShader: `
        varying vec3 vPaint;
        void main() {
          float intensity = max(max(vPaint.r, vPaint.g), vPaint.b);
          if (intensity < 0.0001) discard;
          float alpha = clamp(intensity * ${OVERLAY_GLOBAL_OPACITY.toFixed(2)}, 0.0, 0.9);
          gl_FragColor = vec4(vPaint.rgb, alpha);
        }`
    });

    const overlay = new THREE.Mesh(mesh.geometry, overlayMat);
    overlay.name = (mesh.name || mesh.uuid) + '_paintOverlay';
    overlay.renderOrder = 999;
    overlay.frustumCulled = false;
    mesh.add(overlay);
    mesh.userData._paintOverlay = overlay;
    return overlay;
  }

  // paint accumulation strategy: blend toward brush color (avoid simple additive)
  const PAINT_STRENGTH = 0.3;

  function applyBrushAtWorldPoint(mesh, worldPoint, worldRadius, brushColorHex, isErase=false) {
    if (!mesh || !mesh.geometry || !mesh.geometry.boundsTree) return;
    const geom = mesh.geometry;
    const colorAttr = ensurePaintColorAttribute(geom);
    if (!colorAttr) return;
    const localCenter = worldPoint.clone(); mesh.worldToLocal(localCenter);
    const s = mesh.getWorldScale(new THREE.Vector3()); const avgScale = (Math.abs(s.x)+Math.abs(s.y)+Math.abs(s.z))/3;
    const localRadius = Math.max(0.0001, worldRadius / Math.max(0.0001, avgScale));

    const triangles = [];
    try {
      geom.boundsTree.shapecast({
        intersectsBounds: box => box.distanceToPoint(localCenter) <= localRadius,
        intersectsTriangle: tri => { triangles.push(tri.clone()); }
      });
    } catch (err) { console.warn('shapecast failed', err); }

    if (!triangles.length) return;
    const posAttr = geom.attributes.position;
    const posArray = posAttr.array;
    const colArray = colorAttr.array;
    const posCount = posAttr.count;

    function findVertexIndexLocal(localVec) {
      const eps = 1e-6;
      for (let i=0;i<posCount;i++){
        const ix = i*3;
        if ( Math.abs(posArray[ix] - localVec.x) <= eps &&
             Math.abs(posArray[ix+1] - localVec.y) <= eps &&
             Math.abs(posArray[ix+2] - localVec.z) <= eps ) return i;
      }
      return -1;
    }

    const brushColor = new THREE.Color(brushColorHex);

    for (let t=0;t<triangles.length;t++){
      const tri = triangles[t];
      const localA = tri.a.clone(), localB = tri.b.clone(), localC = tri.c.clone();
      const worldA = localA.clone(); mesh.localToWorld(worldA);
      const worldB = localB.clone(); mesh.localToWorld(worldB);
      const worldC = localC.clone(); mesh.localToWorld(worldC);

      const da = worldA.distanceTo(worldPoint), db = worldB.distanceTo(worldPoint), dc = worldC.distanceTo(worldPoint);
      const wA = Math.max(0, 1 - (da / worldRadius));
      const wB = Math.max(0, 1 - (db / worldRadius));
      const wC = Math.max(0, 1 - (dc / worldRadius));

      const ia = findVertexIndexLocal(localA), ib = findVertexIndexLocal(localB), ic = findVertexIndexLocal(localC);
      const streng = PAINT_STRENGTH;
      if (ia >= 0) {
        const off = ia*3;
        if (isErase) { colArray[off]=0; colArray[off+1]=0; colArray[off+2]=0; }
        else {
          colArray[off]   = colArray[off]   + (brushColor.r - colArray[off])   * (wA * streng);
          colArray[off+1] = colArray[off+1] + (brushColor.g - colArray[off+1]) * (wA * streng);
          colArray[off+2] = colArray[off+2] + (brushColor.b - colArray[off+2]) * (wA * streng);
        }
      }
      if (ib >= 0) {
        const off = ib*3;
        if (isErase) { colArray[off]=0; colArray[off+1]=0; colArray[off+2]=0; }
        else {
          colArray[off]   = colArray[off]   + (brushColor.r - colArray[off])   * (wB * streng);
          colArray[off+1] = colArray[off+1] + (brushColor.g - colArray[off+1]) * (wB * streng);
          colArray[off+2] = colArray[off+2] + (brushColor.b - colArray[off+2]) * (wB * streng);
        }
      }
      if (ic >= 0) {
        const off = ic*3;
        if (isErase) { colArray[off]=0; colArray[off+1]=0; colArray[off+2]=0; }
        else {
          colArray[off]   = colArray[off]   + (brushColor.r - colArray[off])   * (wC * streng);
          colArray[off+1] = colArray[off+1] + (brushColor.g - colArray[off+1]) * (wC * streng);
          colArray[off+2] = colArray[off+2] + (brushColor.b - colArray[off+2]) * (wC * streng);
        }
      }
    } // triangles
    colorAttr.needsUpdate = true;
  }

  // ---------- UI behavior & mutual exclusivity ----------
  let moveAxisMode = false;
  let isAxisSelected = false;
  let drawMode = false;
  let tool = 'pen';
  let terrainPenActive = false;
  let terrainDrawing = false;

  modeRadios.forEach(r => r.addEventListener('change', ()=> {
    tool = document.querySelector('input[name="tool"]:checked').value;
    eraserControls.style.display = tool === 'eraser' ? 'block' : 'none';
  }));

  // IMPORTANT: when drawMode toggled, block rotate and ensure terrain pen is off
  drawModeCheckbox.addEventListener('change', ()=> {
    drawMode = drawModeCheckbox.checked;
    if (drawMode) {
      // Disable terrain pen if active
      if (terrainPenActive) {
        terrainPenActive = false;
        terrainPenBtn.classList.remove('active');
        terrainPenBtn.textContent = 'Terrain Pen';
      }
      // Block rotation so left = draw; right = pan; wheel = zoom
      controls.enableRotate = false;
    } else {
      // restore rotation only if terrain pen isn't active
      if (!terrainPenActive) controls.enableRotate = true;
    }
  });

  moveAxisBtn.addEventListener('click', ()=> {
    moveAxisMode = !moveAxisMode;
    if (moveAxisMode) { moveAxisBtn.classList.add('active'); moveAxisBtn.textContent='Muovi assi (attivo)'; drawModeCheckbox.checked=false; drawMode=false; controls.enableRotate=true; }
    else { moveAxisBtn.classList.remove('active'); moveAxisBtn.textContent='Muovi assi'; isAxisSelected=false; controls.enableRotate=true; }
  });

  thicknessInput.addEventListener('input', ()=> thicknessVal.textContent = parseInt(thicknessInput.value,10));
  eraserSizeInput.addEventListener('input', ()=> eraserVal.textContent = eraserSizeInput.value);

  clearBtn.addEventListener('click', ()=> {
    // clear terrain paint
    if (terrainMesh && terrainMesh.geometry && terrainMesh.geometry.attributes.color) {
      terrainMesh.geometry.attributes.color.array.fill(0);
      terrainMesh.geometry.attributes.color.needsUpdate = true;
    }
    // clear line strokes
    for (const s of strokes) {
      for (const seg of s.segments) {
        scene.remove(seg);
        if (seg.geometry) seg.geometry.dispose();
        if (seg.material) seg.material.dispose();
      }
    }
    strokes.length = 0;
  });

  terrainPenBtn.addEventListener('click', ()=> {
    terrainPenActive = !terrainPenActive;
    if (terrainPenActive) {
      terrainPenBtn.classList.add('active'); terrainPenBtn.textContent='Terrain Pen (attivo)';
      // mutual exclusivity: disable line draw
      drawModeCheckbox.checked = false; drawMode = false;
      if (!terrainMesh) {
        if (model) {
          terrainMesh = chooseLargestMesh(model);
          if (terrainMesh) { prepareMeshForPainting(terrainMesh); selectedTerrainNameEl.innerHTML = 'Terrain: <strong>' + (terrainMesh.name||terrainMesh.uuid||'unnamed') + '</strong>'; }
          else { selectedTerrainNameEl.innerHTML = 'Terrain: <em>nessuno</em>'; alert('Nessuna mesh trovata'); terrainPenActive=false; terrainPenBtn.classList.remove('active'); }
        } else { alert('Carica prima un modello.'); terrainPenActive=false; terrainPenBtn.classList.remove('active'); }
      }
      controls.enableRotate = false;
    } else {
      terrainPenBtn.classList.remove('active'); terrainPenBtn.textContent='Terrain Pen'; terrainDrawing=false; controls.enableRotate=true;
    }
  });

  // ---------- load remote Campi ----------
  loadCampiBtn.addEventListener('click', ()=> {
    if (isLoadingCampi) return;
    if (currentModelSourceUrl === CAMPI_URL && model) { loadCampiBtn.textContent='Modello già caricato'; setTimeout(()=> loadCampiBtn.textContent='Carica modello Campi Flegrei', 1200); return; }
    if (model) removeModel();
    isLoadingCampi = true; loadCampiBtn.disabled = true; loadCampiBtn.textContent = 'Caricamento...';
    gltfLoader.load(CAMPI_URL, (gltf) => {
      model = gltf.scene; scene.add(model); model.updateMatrixWorld(true);
      const info = fitCameraToObject(model, 2.0);
      createAxisHelper(info.center);
      terrainMesh = chooseLargestMesh(model);
      if (terrainMesh) { prepareMeshForPainting(terrainMesh); selectedTerrainNameEl.innerHTML = 'Terrain: <strong>' + (terrainMesh.name||terrainMesh.uuid||'unnamed') + '</strong>'; }
      else selectedTerrainNameEl.innerHTML = 'Terrain: <em>nessuno</em>';
      currentModelSourceUrl = CAMPI_URL; isLoadingCampi=false; loadCampiBtn.disabled=false; loadCampiBtn.textContent='Carica modello Campi Flegrei';
      document.getElementById('dropHint').classList.add('hidden'); updateDropHintVisibility();
    }, undefined, (err)=> { console.error('Errore',err); isLoadingCampi=false; loadCampiBtn.disabled=false; loadCampiBtn.textContent='Carica modello Campi Flegrei'; alert('Errore caricamento'); });
  });

  // ---------- drag & drop ----------
  function handleFileDrop(file) {
    const name = file.name.toLowerCase();
    if (!name.endsWith('.glb') && !name.endsWith('.gltf')) { alert('File non supportato'); return; }
    const url = URL.createObjectURL(file);
    if (model) removeModel();
    gltfLoader.load(url, (gltf) => {
      model = gltf.scene; scene.add(model); model.updateMatrixWorld(true);
      const info = fitCameraToObject(model, 2.0);
      createAxisHelper(info.center);
      terrainMesh = chooseLargestMesh(model);
      if (terrainMesh) { prepareMeshForPainting(terrainMesh); selectedTerrainNameEl.innerHTML = 'Terrain: <strong>' + (terrainMesh.name||terrainMesh.uuid||'unnamed') + '</strong>'; }
      else selectedTerrainNameEl.innerHTML = 'Terrain: <em>nessuno</em>';
      currentModelSourceUrl = 'local:' + file.name;
      document.getElementById('dropHint').classList.add('hidden');
      URL.revokeObjectURL(url);
      updateDropHintVisibility();
    }, undefined, (err)=> { console.error('load error',err); URL.revokeObjectURL(url); alert('Errore caricamento'); });
  }
  window.addEventListener('dragover', (e)=> { e.preventDefault(); if (!model) document.getElementById('dropHint').classList.remove('hidden');});
  window.addEventListener('drop', (e)=> { e.preventDefault(); if (!e.dataTransfer || !e.dataTransfer.files || e.dataTransfer.files.length===0) return; handleFileDrop(e.dataTransfer.files[0]); });

  // ---------- prepare mesh: BVH + overlay ----------
  function prepareMeshForPainting(mesh) {
    if (!mesh || !mesh.geometry) return;
    const geom = mesh.geometry;
    if (!geom.boundsTree) geom.boundsTree = new MeshBVH(geom, { lazyGeneration:false });
    ensurePaintColorAttribute(geom);
    if (!mesh.userData._paintOverlay) createOverlayForMesh(mesh);
  }

  function chooseLargestMesh(root) {
    if (!root) return null;
    let best=null, bestVol=-Infinity;
    root.traverse(o=> {
      if (o.isMesh && o.geometry) {
        if (!o.geometry.boundingBox) o.geometry.computeBoundingBox();
        const b = o.geometry.boundingBox; const s = new THREE.Vector3(); b.getSize(s);
        const vol = Math.abs(s.x*s.y*s.z);
        if (vol > bestVol) { bestVol = vol; best = o; }
      }
    });
    return best;
  }

  // ---------- pointer handlers ----------
  function getPointerFromEvent(e) {
    const rect = renderer.domElement.getBoundingClientRect();
    pointer.x = ( (e.clientX - rect.left) / rect.width ) * 2 - 1;
    pointer.y = - ( (e.clientY - rect.top) / rect.height ) * 2 + 1;
    return pointer.clone();
  }

  // eraser hover for lines
  function updateEraserHighlightScreen(e) {
    const p = getPointerFromEvent(e);
    raycaster.setFromCamera(p, camera);
    if (!drawMode && !terrainPenActive) return;
    if (!terrainPenActive && tool === 'eraser') {
      // clear previous highlights
      for (const s of strokes) for (const seg of s.segments) {
        if (seg.userData._highlighted) { if (seg.userData._colorHex !== undefined) seg.material.color.setHex(seg.userData._colorHex); seg.userData._highlighted=false; }
      }
      const rect = renderer.domElement.getBoundingClientRect();
      for (const s of strokes) {
        for (const seg of s.segments) {
          const a = seg.userData._a, b = seg.userData._b;
          // approximate: project midpoint to screen and compare distance in px
          const mid = a.clone().add(b).multiplyScalar(0.5);
          const proj = mid.clone().project(camera);
          const sx = (proj.x*0.5+0.5)*renderer.domElement.width;
          const sy = (-proj.y*0.5+0.5)*renderer.domElement.height;
          const dx = sx - (e.clientX - rect.left);
          const dy = sy - (e.clientY - rect.top);
          const distPx = Math.sqrt(dx*dx+dy*dy);
          const eraserPx = Math.max(8, parseFloat(eraserSizeInput.value));
          if (distPx <= eraserPx) {
            seg.userData._highlighted = true;
            seg.userData._colorHex = seg.userData._colorHex || seg.material.color.getHex();
            seg.material.color.setHex(0xFFEE66);
          }
        }
      }
    }
  }

  function onPointerMove(e) {
    const p = getPointerFromEvent(e);
    raycaster.setFromCamera(p, camera);

    // axis halo hover
    if (axisHelper) {
      const sphere = axisHelper.children.find(c => c.name === 'axisHelperCenter');
      const halo = axisHelper.children.find(c => c.name === 'axisHelperHalo');
      if (sphere && halo) {
        const rayOrigin = raycaster.ray.origin, rayDir = raycaster.ray.direction;
        const center = axisHelper.position.clone();
        const v = new THREE.Vector3().subVectors(center, rayOrigin);
        const projLen = v.dot(rayDir);
        const closestPoint = rayOrigin.clone().add(rayDir.clone().multiplyScalar(projLen));
        const distToRay = center.distanceTo(closestPoint);
        const sphereRadius = sphere.scale.x;
        const hoverThreshold = sphereRadius * 1.4;
        halo.visible = (moveAxisMode && distToRay <= hoverThreshold);
      }
    }

    // axis dragging
    if (isAxisSelected && moveAxisMode) {
      const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(camera.getWorldDirection(new THREE.Vector3()).clone().negate(), axisHelper.position);
      const p3 = new THREE.Vector3();
      if (raycaster.ray.intersectPlane(plane, p3)) axisHelper.position.copy(p3);
      return;
    }

    // update eraser hover highlight for lines
    updateEraserHighlightScreen(e);

    // LINE DRAWING (classic pen) when drawMode ON and not terrainPenActive
    if (drawMode && !terrainPenActive && drawingLine && currentStroke && tool === 'pen') {
      const pWorld = new THREE.Vector3();
      const camDir = camera.getWorldDirection(new THREE.Vector3()).clone().negate();
      const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(camDir, axisHelper.position);
      if (raycaster.ray.intersectPlane(plane, pWorld)) {
        const snapped = pWorld.clone();
        if (!lastPoint) { lastPoint = snapped.clone(); return; }
        if (snapped.distanceTo(lastPoint) >= minSegmentDistance) {
          const thickness_m = parseInt(thicknessInput.value,10);
          const seg = createLineSegmentBetweenPoints(lastPoint.clone(), snapped.clone(), thickness_m, colorInput.value);
          scene.add(seg);
          currentStroke.segments.push(seg);
          lastPoint.copy(snapped);
        }
      }
    }

    // TERRAIN PAINT dragging
    if (terrainPenActive && !drawMode && terrainDrawing && terrainMesh) {
      const hits = raycaster.intersectObject(terrainMesh, true);
      if (!hits.length) return;
      const hit = hits[0];
      const thicknessVal = Math.max(1, parseInt(thicknessInput.value,10));
      const worldRadius = Math.max(1, thicknessVal);
      const isErase = (tool === 'eraser');
      applyBrushAtWorldPoint(terrainMesh, hit.point.clone(), worldRadius, colorInput.value, isErase);
      return;
    }
  }

  function onPointerDown(e) {
    const p = getPointerFromEvent(e);
    raycaster.setFromCamera(p, camera);

    // axis selection for moving
    if (moveAxisMode && e.button === 0 && axisHelper) {
      const sphere = axisHelper.children.find(c => c.name === 'axisHelperCenter');
      if (sphere) {
        const intersects = raycaster.intersectObject(sphere);
        if (intersects.length > 0) { isAxisSelected = true; controls.enabled = false; e.preventDefault(); e.stopPropagation(); return; }
      }
    }

    // LINE DRAW start (only when tool === 'pen')
    if (drawMode && !terrainPenActive && e.button === 0 && !moveAxisMode && tool === 'pen') {
      // ensure terrain pen off
      if (terrainPenActive) {
        terrainPenActive=false; terrainPenBtn.classList.remove('active'); terrainPenBtn.textContent='Terrain Pen'; controls.enableRotate=true;
      }
      drawingLine = true;
      currentStroke = { segments: [], color: colorInput.value, thickness_m: parseInt(thicknessInput.value,10) };
      strokes.push(currentStroke);
      // origin is axisHelper position
      lastPoint = axisHelper.position.clone();
      // create tiny initial segment to give the stroke a start
      const tiny = lastPoint.clone().add(camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(0.001));
      const seg = createLineSegmentBetweenPoints(lastPoint.clone(), tiny.clone(), parseInt(thicknessInput.value,10), colorInput.value);
      scene.add(seg);
      currentStroke.segments.push(seg);
      // while drawing, make sure rotation is disabled so left stays drawing
      controls.enableRotate = false;
      e.preventDefault(); e.stopPropagation(); return;
    }

    // TERRAIN PAINT start
    if (terrainPenActive && !drawMode && e.button === 0 && terrainMesh) {
      const hits = raycaster.intersectObject(terrainMesh, true);
      if (hits.length) {
        terrainDrawing = true;
        const hit = hits[0];
        const thicknessVal = Math.max(1, parseInt(thicknessInput.value,10));
        const worldRadius = Math.max(1, thicknessVal);
        const isErase = (tool === 'eraser');
        applyBrushAtWorldPoint(terrainMesh, hit.point.clone(), worldRadius, colorInput.value, isErase);
        e.preventDefault(); e.stopPropagation(); return;
      }
    }

    // Eraser click on lines (if eraser and drawMode lines)
    if (tool === 'eraser' && drawMode && !terrainPenActive && e.button === 0) {
      // remove highlighted segments
      for (let i=strokes.length-1;i>=0;i--) {
        const stroke = strokes[i];
        for (let j=stroke.segments.length-1;j>=0;j--) {
          const seg = stroke.segments[j];
          if (seg.userData._highlighted) {
            scene.remove(seg);
            if (seg.geometry) seg.geometry.dispose();
            if (seg.material) seg.material.dispose();
            stroke.segments.splice(j,1);
          }
        }
        if (stroke.segments.length === 0) strokes.splice(i,1);
      }
    }

    // Eraser click when terrainPenActive -> apply erase
    if (tool === 'eraser' && terrainPenActive && e.button === 0 && terrainMesh) {
      const hits = raycaster.intersectObject(terrainMesh, true);
      if (hits.length) {
        const hit = hits[0];
        const worldRadius = Math.max(1, parseInt(eraserSizeInput.value,10));
        applyBrushAtWorldPoint(terrainMesh, hit.point.clone(), worldRadius, colorInput.value, true);
      }
    }
  }

  function onPointerUp(e) {
    if (e.button === 0 && isAxisSelected && moveAxisMode) { isAxisSelected=false; controls.enabled=true; e.preventDefault(); e.stopPropagation(); return; }
    if (drawingLine) { drawingLine=false; currentStroke=null; lastPoint=null; }
    if (terrainDrawing) terrainDrawing=false;
    // keep controls.enableRotate state consistent:
    // if drawMode is still enabled or terrainPen active, keep rotate disabled; otherwise enable
    if (!drawMode && !terrainPenActive) controls.enableRotate = true;
  }

  // ---------- remove model ----------
  function removeModel() {
    if (!model) return;
    model.traverse(o => {
      if (o.userData && o.userData._paintOverlay) {
        try { o.remove(o.userData._paintOverlay); if (o.userData._paintOverlay.material) o.userData._paintOverlay.material.dispose(); } catch(e) {}
        o.userData._paintOverlay = null;
      }
    });
    scene.remove(model);
    model.traverse(c => {
      if (c.geometry) c.geometry.dispose();
      if (c.material) {
        if (Array.isArray(c.material)) c.material.forEach(m => { if (m.map) m.map.dispose(); m.dispose(); });
        else { if (c.material.map) c.material.map.dispose(); c.material.dispose(); }
      }
    });
    model = null; currentModelSourceUrl = null; terrainMesh = null;
    selectedTerrainNameEl.innerHTML = 'Terrain: <em>nessuno (auto)</em>';
    updateDropHintVisibility();
  }

  // ---------- fit camera ----------
  function fitCameraToObject(object, offsetFactor = 2.2) {
    const box = new THREE.Box3().setFromObject(object);
    const size = new THREE.Vector3(); box.getSize(size);
    const center = new THREE.Vector3(); box.getCenter(center);
    const maxDim = Math.max(size.x,size.y,size.z);
    if (maxDim === 0) return { box, size, center, maxDim, cameraDistance:0 };
    const fov = camera.fov * (Math.PI/180);
    let cameraDistance = Math.abs(maxDim / 2 / Math.tan(fov/2)) * offsetFactor;
    const dir = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
    if (dir.lengthSq() === 0) dir.set(0,0,1);
    camera.position.copy(center).addScaledVector(dir, cameraDistance);
    camera.near = Math.max(0.1, cameraDistance / 1000);
    camera.far = cameraDistance * 1000;
    camera.updateProjectionMatrix();
    controls.target.copy(center); controls.update();
    return { box, size, center, maxDim, cameraDistance };
  }

  // ---------- init / events ----------
  createAxisHelper(new THREE.Vector3(0,0,0));
  updateDropHintVisibility();

  renderer.domElement.addEventListener('pointermove', onPointerMove);
  renderer.domElement.addEventListener('pointerdown', onPointerDown);
  window.addEventListener('pointerup', onPointerUp);
  renderer.domElement.addEventListener('contextmenu', (e)=> e.preventDefault());

  window.addEventListener('resize', ()=> {
    renderer.setSize(container.clientWidth, container.clientHeight);
    camera.aspect = container.clientWidth / container.clientHeight;
    camera.updateProjectionMatrix();
    updateAxisCenterVisualSize();
    // update resolution for any LineMaterial
    scene.traverse(obj => {
      if (obj.isLine2 && obj.material && obj.material.resolution) {
        obj.material.resolution.set(renderer.domElement.width, renderer.domElement.height);
        obj.material.needsUpdate = true;
      }
    });
  });

  function updateDropHintVisibility() {
    const dropHintEl = document.getElementById('dropHint');
    if (!dropHintEl) return;
    if (model) dropHintEl.classList.add('hidden'); else dropHintEl.classList.remove('hidden');
  }

  function animate() {
    requestAnimationFrame(animate);
    updateAxisCenterVisualSize();
    renderer.render(scene, camera);
  }
  animate();

  // expose for debugging
  window._cf = { scene, camera, renderer, chooseLargestMesh, applyBrushAtWorldPoint, strokes };

})(); // end IIFE
</script>
</body>
</html>
