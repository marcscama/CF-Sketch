<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>terremoti-07-2025</title>
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<base target="_blank">
<link rel="stylesheet" type="text/css" href="./Qgis2threejs.css">
<style type="text/css">
#popup, #header, #layerpanel {
  left: 36px;
}
</style>
<script src="./threejs/three.min.js"></script>
<script src="./threejs/OrbitControls.js"></script>
<script src="./threejs/ViewHelper.js"></script>
<script src="./threejs/OutlineEffect.js"></script>
<script src="./Qgis2threejs.js"></script>
</head>
<body>
<div id="view">
  <div id="northarrow"></div>
  <div id="navigation"></div>
</div>

<!-- popup -->
<div id="popup">
  <div id="closebtn">&times;</div>
  <div id="popupbar"></div>
  <div id="popupbody">
    <div id="popupcontent"></div>

    <!-- query result -->
    <div id="queryresult">
      <table id="qr_coords_table">
        <caption>Clicked coordinates <div id="zoomtopoint" class="action-zoom zoombtn"></div></caption>
        <tr><td id="qr_coords"></td></tr>
      </table>

      <table id="qr_layername_table">
        <caption>Layer <div id="zoomtolayer" class="action-zoom zoombtn"></div></caption>
        <tr><td id="qr_layername"></td></tr>
      </table>

      <table id="qr_attrs_table">
        <caption>Attributes</caption>
      </table>

      <!-- camera actions and measure tool -->
      <div id="orbitbtn" class="action-btn action-orbit">Orbit</div>
      <div id="measurebtn" class="action-btn">Measure distance</div>
    </div>

    <!-- page info -->
    <div id="pageinfo">
      <h1>Current View URL</h1>
      <div><input id="urlbox" type="text"></div>

      <h1>Usage</h1>
      <table id="usage">
        <tr><td colspan="2" class="star">Mouse</td></tr>
        <tr><td>Left button + Move</td><td>Orbit</td></tr>
        <tr><td>Mouse Wheel</td><td>Zoom</td></tr>
        <tr><td>Right button + Move</td><td>Pan</td></tr>

        <tr><td colspan="2" class="star">Keys</td></tr>
        <tr><td>Arrow keys</td><td>Move Horizontally</td></tr>
        <tr><td>Shift + Arrow keys</td><td>Orbit</td></tr>
        <tr><td>Ctrl + Arrow keys</td><td>Rotate</td></tr>
        <tr><td>Shift + Ctrl + Up / Down</td><td>Zoom In / Out</td></tr>
        <tr><td>L</td><td>Toggle Label Visibility</td></tr>
        <tr><td>R</td><td>Start / Stop Orbit Animation</td></tr>
        <tr><td>W</td><td>Wireframe Mode</td></tr>
        <tr><td>Shift + R</td><td>Reset Camera Position</td></tr>
        <tr><td>Shift + S</td><td>Save Image</td></tr>
      </table>

      <h1>About</h1>
      <div id="about"><img src="./Qgis2threejs.png">
        This page was made with <a href="https://www.qgis.org/">QGIS</a> and <a href="https://github.com/minorua/Qgis2threejs">Qgis2threejs</a> plugin (version 2.8).
        <div>Powered by <a href="https://threejs.org/">three.js</a>
        <span id="lib_proj4js"> and <a href="https://trac.osgeo.org/proj4js/">Proj4js</a></span>.</div>
      </div>
    </div>
  </div>
</div>

<!-- progress bar -->
<div id="progress"><div id="progressbar"></div></div>

<!-- menu -->
<div id="toolbtns">
  <div id="layerbtn"></div>
  <div id="animbtn" class="hidden"></div>
  <div id="infobtn"></div>
</div>

<!-- header and footer -->
<div id="header"></div>
<div id="footer"></div>

<!-- layer panel -->
<div id="layerpanel">
  <div id="layerlist"></div>
</div>

<!-- animation -->
<div id="narrativebox" class="ef1">
  <div id="narbody">

  </div>
  <div id="nextbtn"></div>
</div>

<script>
Q3D.Config.allVisible = true;
Q3D.Config.bgColor = 0xffffff;
Q3D.Config.viewpoint = {lookAt:{x:426248.434989865,y:4517666.811603576,z:-1.1839921050606837e-15},pos:{x:432420.6401290015,y:4504911.042410877,z:3937.8688261482375}};
Q3D.Config.localMode = true;

var container = document.getElementById("view"),
    app = Q3D.application,
    gui = Q3D.gui;

app.init(container);       // initialize viewer

// ---------- SOSTITUISCI qui la chiamata app.loadSceneFile con la versione che chiama il callback pulito ----------
app.loadSceneFile("./data/index/scene.js",
  function(scene) {
    // scene file loaded
    app.start();
  },
  function(scene) {
    // all relevant files have been loaded -> qui la scena è pronta
    try {
      const THREE = window.THREE;
      // preferisci app.scene se presente
      const threeScene = (scene && scene.isScene) ? scene : (app && app.scene) || window.scene;
      const camera = (app && app.camera) || window.camera || (window.viewer && viewer.camera);
      const renderer = (app && app.renderer) || window.renderer || (window.viewer && viewer.renderer);

      console.log('Callback all files loaded - scene, camera, renderer:', !!threeScene, !!camera, !!renderer);

      if (!THREE || !threeScene || !camera || !renderer) {
        console.warn('Ambiente rendering non disponibile nel callback (THREE/scene/camera/renderer).');
        return;
      }

      // se DTM non esiste stop (ma tu hai detto che il layer si chiama esattamente "DTM")
      const dtm = threeScene.getObjectByName('DTM');
      if (!dtm) {
        console.warn('DTM non trovato nella scena (cercato con getObjectByName("DTM")).');
        return;
      }
      console.log('DTM trovato:', dtm.name);

      // aggiungiamo stile etichette (solo se non esiste)
      if (!document.getElementById('label2d-style')) {
        const s = document.createElement('style');
        s.id = 'label2d-style';
        s.textContent = `
        .label2d {
          padding:2px 6px;
          background:rgba(255,255,255,0.95);
          border:1px solid #000;
          color:#000;
          font-weight:700;
          font-size:12px;
          border-radius:3px;
          white-space:nowrap;
          pointer-events:none;
          position:absolute;
          transform:translate(-50%,-50%);
        }`;
        document.head.appendChild(s);
      }

      // rendi DTM sempre visibile (semi-trasparente)
      dtm.traverse(n => {
        if (n.isMesh) {
          const mats = Array.isArray(n.material) ? n.material : [n.material];
          for (const m of mats) {
            if (!m) continue;
            if (typeof m.opacity !== 'number' || m.opacity === 1) m.opacity = 0.6;
            m.transparent = true;
            m.depthTest = false;
            m.depthWrite = false;
            m.side = THREE.DoubleSide;
            m.needsUpdate = true;
          }
          n.renderOrder = 999;
        }
      });

      // parametri
      const DEPTH = 10000;
      const STEP = 1000;
      const OFFSET_PX = 30;

      // bbox DTM
      const bb = new THREE.Box3().setFromObject(dtm);

      // scegli asse verticale come min dimensione del bbox globale
      const totalBbox = new THREE.Box3().setFromObject(threeScene);
      const totalSize = new THREE.Vector3(); totalBbox.getSize(totalSize);
      let vertIndex = 1;
      if (totalSize.x <= totalSize.y && totalSize.x <= totalSize.z) vertIndex = 0;
      else if (totalSize.z <= totalSize.x && totalSize.z <= totalSize.y) vertIndex = 2;
      const axes2 = [0,1,2].filter(i => i !== vertIndex);

      // punto in basso a destra (2D): max su axes2[0], min su axes2[1]
      const maxA = bb.max.getComponent(axes2[0]);
      const minB = bb.min.getComponent(axes2[1]);

      // superficie Z = bb.max sul vertIndex
      const topZ = bb.max.getComponent(vertIndex);
      const bottomZ = topZ - DEPTH;

      // top corners (0=basso-destra,1=alto-destra,2=alto-sin,3=basso-sin)
      const topCorners = [
        new THREE.Vector3().setComponent(axes2[0], maxA).setComponent(axes2[1], minB).setComponent(vertIndex, topZ),
        new THREE.Vector3().setComponent(axes2[0], maxA).setComponent(axes2[1], bb.max.getComponent(axes2[1])).setComponent(vertIndex, topZ),
        new THREE.Vector3().setComponent(axes2[0], bb.min.getComponent(axes2[0])).setComponent(axes2[1], bb.max.getComponent(axes2[1])).setComponent(vertIndex, topZ),
        new THREE.Vector3().setComponent(axes2[0], bb.min.getComponent(axes2[0])).setComponent(axes2[1], minB).setComponent(vertIndex, topZ)
      ];
      const bottomCorners = topCorners.map(c => c.clone().setComponent(vertIndex, bottomZ));

      // helper per linee
      const matLine = new THREE.LineBasicMaterial({ color: 0x000000 });
      function addLine(p1, p2) {
        const geom = new THREE.BufferGeometry().setFromPoints([p1.clone(), p2.clone()]);
        const l = new THREE.Line(geom, matLine);
        threeScene.add(l);
        return l;
      }

      // disegna contorni (top, bottom, verticali)
      addLine(topCorners[0], topCorners[1]); addLine(topCorners[1], topCorners[2]);
      addLine(topCorners[2], topCorners[3]); addLine(topCorners[3], topCorners[0]);
      addLine(bottomCorners[0], bottomCorners[1]); addLine(bottomCorners[1], bottomCorners[2]);
      addLine(bottomCorners[2], bottomCorners[3]); addLine(bottomCorners[3], bottomCorners[0]);
      for (let i = 0; i < 4; i++) addLine(topCorners[i], bottomCorners[i]);

      // etichette solo sulla colonna basso-destra (topCorners[0] -> bottomCorners[0])
      const labels = [];
      const cornerTop = topCorners[0].clone();

      // direzione outward per offset
      const centerFoot = new THREE.Vector3();
      centerFoot.setComponent(axes2[0], (bb.max.getComponent(axes2[0]) + bb.min.getComponent(axes2[0])) / 2);
      centerFoot.setComponent(axes2[1], (bb.max.getComponent(axes2[1]) + bb.min.getComponent(axes2[1])) / 2);
      centerFoot.setComponent(vertIndex, 0);
      const dirOut = cornerTop.clone().setComponent(vertIndex, 0).sub(centerFoot.clone().setComponent(vertIndex, 0));
      if (dirOut.lengthSq() < 1e-6) { dirOut.setComponent(axes2[0], 1); dirOut.setComponent(axes2[1], 0); }
      dirOut.setComponent(vertIndex, 0); dirOut.normalize();

      const footprintSize = Math.max(bb.getSize(new THREE.Vector3()).x, bb.getSize(new THREE.Vector3()).y);
      const labelOffset = OFFSET_PX * 0.01 * footprintSize;

      for (let d = STEP; d <= DEPTH; d += STEP) {
        const z = topZ - d;
        const pos = cornerTop.clone().setComponent(vertIndex, z);
        const posOut = pos.clone().add(dirOut.clone().multiplyScalar(labelOffset));
        const div = document.createElement('div');
        div.className = 'label2d';
        div.textContent = `-${d} m`;
        document.body.appendChild(div);
        labels.push({ el: div, pos: posOut.clone() });
      }

      // update loop etichette
      (function updateLabels() {
        requestAnimationFrame(updateLabels);
        try {
          for (const L of labels) {
            const p = L.pos.clone().project(camera);
            if (p.z < -1 || p.z > 1) { L.el.style.display = 'none'; continue; }
            const sx = (p.x + 1) * 0.5 * renderer.domElement.clientWidth;
            const sy = (1 - p.y) * 0.5 * renderer.domElement.clientHeight;
            L.el.style.display = '';
            L.el.style.left = Math.round(sx) + 'px';
            L.el.style.top = Math.round(sy) + 'px';
          }
        } catch (e) { /* ignore */ }
      })();

      console.log('Parallelepipedo aggiunto — topZ:', topZ, ' bottomZ:', bottomZ, ' cornerXY:', maxA, minB);

    } catch (err) {
      console.error('Errore nel callback parallelepipedo:', err);
    }
  }
);
</script>

</body>
</html>
